'use strict'

const _ = require('lodash')

const debug = require('debug')('fun:ram')
const Client = require('./fc/client')
const { promiseRetry } = require('./common')
const Logger = require('./logger')

class RAM extends Client {
  constructor (credentials) {
    super(credentials)
    this.ramClient = this.buildRamClient()
    this.logger = new Logger()
  }

  normalizeRoleOrPoliceName (roleName) {
    return roleName.replace(/_/g, '-')
  }

  async getRamRole (roleName) {
    try {
      return await this.ramClient.getRole({
        RoleName: roleName
      })
    } catch (ex) {
      if (ex.name !== 'EntityNotExist.RoleError') {
        console.error('error when getRole: %s, error is: \n%O', roleName, ex)
        throw ex
      }
    }
  }

  async existsRamRole (roleName) {
    try {
      await this.ramClient.getRole({
        RoleName: roleName
      })
      return true
    } catch (ex) {
      if (ex.name === 'EntityNotExist.RoleError') {
        return false
      }
      throw ex
    }
  }

  async makeRole (roleName, createRoleIfNotExist, description = 'FunctionCompute Default Role', assumeRolePolicy) {
    let role

    await promiseRetry(async (retry, times) => {
      try {
        role = await this.getRamRole(roleName)

        if (!assumeRolePolicy) {
          assumeRolePolicy = {
            Statement: [
              {
                Action: 'sts:AssumeRole',
                Effect: 'Allow',
                Principal: {
                  Service: [
                    'fc.aliyuncs.com'
                  ]
                }
              }
            ],
            Version: '1'
          }
        }

        if (!role && createRoleIfNotExist) {
          role = await this.ramClient.createRole({
            RoleName: roleName,
            Description: description,
            AssumeRolePolicyDocument: JSON.stringify(assumeRolePolicy)
          })
        } else if (!role) {
          throw new Error(`role ${roleName} not exist`)
        }
      } catch (ex) {
        debug('error when makeRole: %s, error is: \n%O', roleName, ex)

        if (ex.code && ex.code.startsWith('InvalidParameter')) {
          throw ex
        } else if (ex.code && ex.code === 'NoPermission') {
          throw ex
        } else {
          this.logger.info(`retry ${times} times`)
          retry(ex)
        }
      }
    })

    return role
  }

  async deletePolicyNotDefaultVersion (policyName) {
    const listResponse = await this.ramClient.listPolicyVersions({
      PolicyType: 'Custom',
      PolicyName: policyName
    })

    const versions = (listResponse.PolicyVersions || {}).PolicyVersion
    if (versions) {
      for (const version of versions) {
        if (version.IsDefaultVersion === false) {
          await this.ramClient.deletePolicyVersion({
            PolicyName: policyName,
            VersionId: version.VersionId
          })
        }
      }
    }
  }

  async makePolicy (policyName, policyDocument) {
    let exists = true
    await promiseRetry(async (retry, times) => {
      try {
        try {
          await this.ramClient.getPolicy({
            PolicyType: 'Custom',
            PolicyName: policyName
          })
        } catch (ex) {
          if (ex.code !== 'EntityNotExist.Policy') {
            throw ex
          } else { exists = false }
        }

        if (!exists) {
          await this.ramClient.createPolicy({
            PolicyName: policyName,
            Description: 'generated by serverless tool',
            PolicyDocument: JSON.stringify(policyDocument)
          })
        } else {
          // avoid limitExceeded.Policy.Version
          await this.deletePolicyNotDefaultVersion(policyName)

          await this.ramClient.createPolicyVersion({
            PolicyName: policyName,
            PolicyDocument: JSON.stringify(policyDocument),
            SetAsDefault: true
          })
        }
      } catch (ex) {
        if (ex.code && ex.code === 'NoPermission') {
          throw ex
        }
        this.logger.info(`retry ${times} times`)
        retry(ex)
      }
    })
  }

  async attachPolicyToRole (policyName, roleName, policyType = 'System') {
    await promiseRetry(async (retry, times) => {
      try {
        const policies = await this.ramClient.listPoliciesForRole({
          RoleName: roleName
        })

        const policy = policies.Policies.Policy.find((item) => {
          return _.toLower(item.PolicyName) === _.toLower(policyName)
        })
        if (!policy) {
          await this.ramClient.attachPolicyToRole({
            PolicyType: policyType,
            PolicyName: policyName,
            RoleName: roleName
          })
        }
      } catch (ex) {
        if (ex.code && ex.code === 'NoPermission') {
          throw ex
        }
        debug('error when attachPolicyToRole: %s, policyName %s, error is: \n%O', roleName, policyName, ex)

        this.logger.info(`retry ${times} times`)
        retry(ex)
      }
    })
  }

  async makeAndAttachPolicy (policyName, policyDocument, roleName) {
    debug('begin makePolicy')
    await this.makePolicy(policyName, policyDocument)
    debug('begin attachPolicyToRole')
    await this.attachPolicyToRole(policyName, roleName, 'Custom')
  }
}

module.exports = RAM
