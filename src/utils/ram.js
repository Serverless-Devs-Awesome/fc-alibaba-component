'use strict'

const _ = require('lodash')

const debug = require('debug')('fun:ram')
const Ram = require('@alicloud/ram')

const { red } = require('colors')
const { promiseRetry } = require('./common')

class RAM {
  constructor (credentials) {
    this.accessKeyID = credentials.AccessKeyID
    this.accessKeySecret = credentials.AccessKeySecret
    this.ramClient = new Ram({
      accessKeyId: this.accessKeyID,
      accessKeySecret: this.accessKeySecret,
      endpoint: 'https://ram.aliyuncs.com',
      opts: {
        timeout: 60000
      }
    })
  }

  normalizeRoleOrPoliceName (roleName) {
    return roleName.replace(/_/g, '-')
  }

  async getRamRole (roleName) {
    try {
      return await this.ramClient.getRole({
        RoleName: roleName
      })
    } catch (ex) {
      console.error('error when getRole: %s, error is: \n%O', roleName, ex)
      if (ex.name !== 'EntityNotExist.RoleError') {
        throw ex
      }
    }
  }

  async makeRole (roleName, createRoleIfNotExist, description = 'FunctionCompute Default Role', assumeRolePolicy) {
    let role

    await promiseRetry(async (retry, times) => {
      try {
        role = await this.getRamRole(roleName)

        if (!assumeRolePolicy) {
          assumeRolePolicy = {
            Statement: [
              {
                Action: 'sts:AssumeRole',
                Effect: 'Allow',
                Principal: {
                  Service: [
                    'fc.aliyuncs.com'
                  ]
                }
              }
            ],
            Version: '1'
          }
        }

        if (!role && createRoleIfNotExist) {
          role = await this.ramClient.createRole({
            RoleName: roleName,
            Description: description,
            AssumeRolePolicyDocument: JSON.stringify(assumeRolePolicy)
          })
        } else if (!role) {
          throw new Error(`role ${roleName} not exist`)
        }
      } catch (ex) {
        debug('error when makeRole: %s, error is: \n%O', roleName, ex)

        if (ex.code && ex.code.startsWith('InvalidParameter')) {
          throw ex
        } else if (ex.code && ex.code === 'NoPermission') {
          throw ex
        } else {
          console.log(red(`retry ${times} times`))
          retry(ex)
        }
      }
    })

    return role
  }

  async deletePolicyNotDefaultVersion (policyName) {
    const listResponse = await this.ramClient.listPolicyVersions({
      PolicyType: 'Custom',
      PolicyName: policyName
    })

    const versions = (listResponse.PolicyVersions || {}).PolicyVersion
    if (versions) {
      for (const version of versions) {
        if (version.IsDefaultVersion === false) {
          await this.ramClient.deletePolicyVersion({
            PolicyName: policyName,
            VersionId: version.VersionId
          })
        }
      }
    }
  }

  async makePolicy (policyName, policyDocument) {
    let exists = true
    await promiseRetry(async (retry, times) => {
      try {
        try {
          await this.ramClient.getPolicy({
            PolicyType: 'Custom',
            PolicyName: policyName
          })
        } catch (ex) {
          if (ex.code !== 'EntityNotExist.Policy') {
            throw ex
          } else { exists = false }
        }

        if (!exists) {
          await this.ramClient.createPolicy({
            PolicyName: policyName,
            Description: 'generated by serverless tool',
            PolicyDocument: JSON.stringify(policyDocument)
          })
        } else {
          // avoid limitExceeded.Policy.Version
          await this.deletePolicyNotDefaultVersion(policyName)

          await this.ramClient.createPolicyVersion({
            PolicyName: policyName,
            PolicyDocument: JSON.stringify(policyDocument),
            SetAsDefault: true
          })
        }
      } catch (ex) {
        if (ex.code && ex.code === 'NoPermission') {
          throw ex
        }
        console.log(red(`retry ${times} times`))
        retry(ex)
      }
    })
  }

  async attachPolicyToRole (policyName, roleName, policyType = 'System') {
    await promiseRetry(async (retry, times) => {
      try {
        const policies = await this.ramClient.listPoliciesForRole({
          RoleName: roleName
        })

        const policy = policies.Policies.Policy.find((item) => {
          return _.toLower(item.PolicyName) === _.toLower(policyName)
        })
        if (!policy) {
          await this.ramClient.attachPolicyToRole({
            PolicyType: policyType,
            PolicyName: policyName,
            RoleName: roleName
          })
        }
      } catch (ex) {
        if (ex.code && ex.code === 'NoPermission') {
          throw ex
        }
        debug('error when attachPolicyToRole: %s, policyName %s, error is: \n%O', roleName, policyName, ex)

        console.log(red(`retry ${times} times`))
        retry(ex)
      }
    })
  }

  async makeAndAttachPolicy (policyName, policyDocument, roleName) {
    debug('begin makePolicy')
    await this.makePolicy(policyName, policyDocument)
    debug('begin attachPolicyToRole')
    await this.attachPolicyToRole(policyName, roleName, 'Custom')
  }

  // async existsRole (roleName) {
  //   try {
  //     const role = await this.ramClient.getRole({ RoleName: roleName })
  //     if (role) {
  //       return true
  //     }
  //   } catch (e) {
  //     if (!e.code) {
  //       throw e
  //     }
  //     const notExists = e.code.indexOf('EntityNotExist') >= 0
  //     return !notExists
  //   }

  //   return false
  // }
}

module.exports = RAM
